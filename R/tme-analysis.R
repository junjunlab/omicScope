
#' Run Tumor Microenvironment (TME) Analysis
#'
#' This function performs comprehensive tumor microenvironment analysis using
#' either deconvolution methods or signature-based approaches. It integrates
#' multiple published algorithms from the IOBR package to decode TME context
#' and calculate immune cell proportions or signature scores.
#'
#' @param object An \code{omicscope} object containing normalized expression data.
#'   The object must have a "normed_counts" assay generated by
#'   \code{get_normalized_data()} function.
#' @param merge_dupGene_method Character string specifying the method to handle
#'   duplicate gene names. Options include "mean" (default), "max", "sum", or
#'   "median". This parameter determines how expression values are aggregated
#'   for genes with identical names.
#' @param method Character string indicating the analysis approach. Choose either
#'   "deconvo" for deconvolution-based cell type estimation or "signature" for
#'   signature-based scoring methods.
#' @param signature_method Character string specifying the signature calculation
#'   method when \code{method = "signature"}. Options include "pca" (Principal
#'   Component Analysis), "ssgsea" (single sample Gene Set Enrichment Analysis),
#'   "zscore" (z-score normalization), or "integration" (integrated approach).
#' @param signature A custom signature list for signature-based analysis. If
#'   \code{NULL} (default), the function uses the built-in \code{signature_tme}
#'   signatures from IOBR package.
#' @param deconvo_method Character string specifying the deconvolution algorithm
#'   when \code{method = "deconvo"}. Available methods include:
#'   \itemize{
#'     \item "cibersort" - CIBERSORT algorithm using support vector regression
#'     \item "mcpcounter" - MCPcounter method with specific marker gene sets
#'     \item "epic" - EPIC method for immune and cancer cell estimation
#'     \item "xcell" - xCell method using gene set enrichment analysis
#'     \item "cibersort_abs" - CIBERSORT with absolute score mode
#'     \item "ips" - Immunophenoscore calculation
#'     \item "quantiseq" - quanTIseq method for immune cell quantification
#'     \item "estimate" - ESTIMATE algorithm for immune and stromal scores
#'     \item "timer" - TIMER method for immune infiltration estimation
#'     \item "svr" - Support Vector Regression approach
#'     \item "lsei" - Least Squares Estimation with Inequality constraints
#'   }
#' @param signature_tme_params Named list of additional parameters passed to
#'   \code{IOBR::calculate_sig_score()} when using signature-based methods.
#'   Default is an empty list.
#' @param deconvo_tme_params Named list of additional parameters passed to
#'   \code{IOBR::deconvo_tme()} when using deconvolution methods. Default
#'   is an empty list with \code{arrays = FALSE} automatically set.
#' @param ... Additional arguments passed to other methods (currently unused).
#'
#' @returns An updated \code{omicscope} object with TME analysis results stored
#'   in the \code{tmeData} slot. Results are stored as:
#'   \itemize{
#'     \item \code{tmeData[["deconvoRes"]]} - Deconvolution results when
#'       \code{method = "deconvo"}
#'     \item \code{tmeData[["signatureRes"]]} - Signature scores when
#'       \code{method = "signature"}
#'   }
#'
#' @details
#' This function serves as a unified interface for multiple TME analysis approaches.
#' Before running TME analysis, the function:
#' \enumerate{
#'   \item Validates that normalized counts are available in the object
#'   \item Handles duplicate gene names using the specified aggregation method
#'   \item Filters out genes with zero expression across all samples
#'   \item Applies log2 transformation with pseudo-count for deconvolution methods
#' }
#'
#' The function requires the IOBR package to be installed and will automatically
#' load it. Different deconvolution methods may have varying accuracy depending
#' on the tissue type and sample characteristics. CIBERSORT and EPIC are
#' generally recommended for immune cell deconvolution, while ESTIMATE provides
#' overall immune and stromal scores.
#'
#'
#' @examples
#' \dontrun{
#' # Load and prepare omicscope object
#' data(example_omicscope)
#' obj <- get_normalized_data(example_omicscope)
#'
#' # Run deconvolution analysis using CIBERSORT
#' obj <- run_TME_analysis(obj,
#'                        method = "deconvo",
#'                        deconvo_method = "cibersort")
#'
#' # Run signature-based analysis using PCA
#' obj <- run_TME_analysis(obj,
#'                        method = "signature",
#'                        signature_method = "pca")
#'
#' # Run analysis with custom parameters
#' obj <- run_TME_analysis(obj,
#'                        method = "deconvo",
#'                        deconvo_method = "epic",
#'                        merge_dupGene_method = "max",
#'                        deconvo_tme_params = list(tumor = TRUE))
#'
#' # Access results
#' deconvo_results <- obj@tmeData[["deconvoRes"]]
#' signature_results <- obj@tmeData[["signatureRes"]]
#' }
#'
#' @importFrom stats aggregate.data.frame
#'
#' @author Jun Zhang
#' @export
setGeneric("run_TME_analysis",function(object,...){
    standardGeneric("run_TME_analysis")
})







#' @rdname run_TME_analysis
#' @export
setMethod("run_TME_analysis",
          signature(object = "omicscope"),
          function(object,
                   merge_dupGene_method = c("mean", "max", "sum", "median"),
                   method = c("deconvo","signature"),
                   signature_method = c("pca", "ssgsea", "zscore", "integration"),
                   signature = NULL,
                   deconvo_method = c("cibersort", "mcpcounter", "epic", "xcell",
                                      "cibersort_abs", "ips", "quantiseq",
                                      "estimate", "timer", "svr", "lsei"),
                   signature_tme_params = list(),
                   deconvo_tme_params = list()){
              merge_dupGene_method <- match.arg(merge_dupGene_method,
                                                choices = c("mean", "max", "sum", "median"))
              method <- match.arg(method, choices = c("deconvo","signature"))
              signature_method <- match.arg(signature_method,
                                            choices = c("pca", "ssgsea", "zscore", "integration"))
              deconvo_method <- match.arg(deconvo_method,
                                          choices = c("cibersort", "mcpcounter", "epic", "xcell",
                                                      "cibersort_abs", "ips", "quantiseq",
                                                      "estimate", "timer", "svr", "lsei"))
              # ================================================================
              # get normalized counts
              ck <- "normed_counts" %in%
                  SummarizedExperiment::assayNames(object)

              if(!ck){
                  stop("Please run get_normalized_data function first!")
              }

              asy <- SummarizedExperiment::assay(object,"normed_counts") |>
                  as.matrix()

              # get anno
              ga <- SummarizedExperiment::rowData(object) |>
                  data.frame(check.names = FALSE)

              # ================================================================
              # deal with duplicate gene names
              rownames(asy) <- ga$gene_name

              dup.gene <- ga$gene_name[duplicated(ga$gene_name)] |> unique()

              uniq.tmp <- asy[!(rownames(asy) %in% dup.gene),] |>
                  data.frame(check.names = FALSE)

              tmp <- asy[rownames(asy) %in% dup.gene,]
              tmp <- tmp[sort(rownames(tmp)),]

              # choose fun
              agg_fun <- switch(merge_dupGene_method,
                                mean = mean,
                                max = max,
                                sum = sum,
                                median = median)

              average.tmp <- stats::aggregate.data.frame(x = tmp,
                                                  by = list(rownames(tmp)),
                                                  FUN = agg_fun) |>
                  tibble::column_to_rownames(var = "Group.1")

              # identical(colnames(uniq.tmp),colnames(average.tmp))

              # merge
              exp <- rbind(uniq.tmp, average.tmp)
              exp <- exp[rowSums(exp) > 0,]
              # ================================================================
              # check IOBR
              if (!requireNamespace("IOBR", quietly = TRUE)) {
                  stop("Package 'IOBR' is required for TME analysis.\n",
                       "Please install it with: devtools::install_github('IOBR/IOBR')")
              }else{
                  library(IOBR)
              }

              # run tme analysis
              mat <- log2(exp + 0.01)

              # check method
              if(method == "deconvo"){
                  tme.res <- do.call(IOBR::deconvo_tme,
                                     modifyList(
                                         list(eset = mat,
                                              method = deconvo_method,
                                              arrays = FALSE),
                                         deconvo_tme_params
                                     ))

                  object@tmeData[["deconvoRes"]] <- tme.res
              }else if(method == "signature"){
                  # check signature
                  if(is.null(signature)){
                      sign <- signature_tme
                  }else{
                      sign <- signature
                  }

                  sig.res <- do.call(IOBR::calculate_sig_score,
                                     modifyList(
                                         list(eset = exp,
                                              method = signature_method),
                                         signature_tme_params
                                     ))

                  object@tmeData[["signatureRes"]] <- sig.res
              }

              return(object)
          })
